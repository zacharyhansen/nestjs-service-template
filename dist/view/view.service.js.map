{"version":3,"sources":["../../src/view/view.service.ts"],"sourcesContent":["import { Inject, Injectable, Logger } from '@nestjs/common';\nimport { sql, type Insertable } from 'kysely';\nimport type {\n  AuthSchema,\n  ConfigurationRoleView,\n  ConfigurationRoleColumn,\n  ConfigurationColumn,\n  ConfigurationView,\n} from 'kysely-codegen';\nimport type { QueryArrayResult } from 'pg';\nimport { supported_pg_data_type } from '@prisma/client';\nimport type { z } from 'zod';\n\nimport {\n  PGDataCellMap,\n  PGDataFieldMap,\n  PostgresSupportedDataTypeIdMap,\n  ViewDefinition,\n} from './view.types';\n\nimport { Database, type TDatabase } from '~/database/database';\nimport { QueryService, type QueryField } from '~/query/query.service';\nimport { SchematicService } from '~/schematic/schematic.service';\n\ninterface Role {\n  schema: AuthSchema;\n  name: string;\n}\n\nexport interface ColumnEnabledRecord {\n  /**\n   * This is assumed to be unique for list as a view cannot have multiple columns of the same name (id is unique within ALL ocnfig (all schems etc.))\n   */\n  name: string;\n  is_pk?: boolean | null;\n  [key: string]: boolean | string | null | undefined;\n}\n\n@Injectable()\nexport class ViewService {\n  private readonly logger = new Logger(ViewService.name);\n\n  constructor(\n    @Inject(Database) private readonly database: Database,\n    private readonly queryService: QueryService,\n    private readonly schematicService: SchematicService\n  ) {}\n\n  // @UseInterceptors(LogTimerInterceptor)\n  async syncViews({\n    schemas,\n  }: {\n    schemas: AuthSchema[];\n    /**\n     * Optional list of views to target/limit the sync with - else all root views are synced only\n     */\n    views?: string[];\n  }) {\n    await sql`select create_configuration_schema_views(ARRAY[${sql.join(schemas)}]::TEXT[]);`.execute(\n      this.database\n    );\n    // eslint-disable-next-line sonarjs/cognitive-complexity\n    await this.database.transaction().execute(async trx => {\n      for (const schema of schemas) {\n        const { schemaCacheMap, schematicViews, schematicLinks } =\n          await this.schematicService.rootSchematic({ schema });\n        // Get all views from information schema\n        // role views will update automatically via cascades\n        const databaseViews = await this.database\n          .selectFrom('information_schema.views')\n          .select(['table_name', 'table_schema', 'view_definition'])\n          .where(\n            'table_name',\n            'in',\n            schematicViews.map(view => view[0].qiName)\n          )\n          .execute();\n\n        // Create sets for efficient lookups\n        const databaseViewSet = new Set(databaseViews.map(v => v.table_name));\n\n        // Fire the view defintion to get the underlying column meta data\n        const columnResults = await Promise.all(\n          databaseViews.map(view =>\n            this.queryService.execute<QueryField[]>({\n              query: sql`\n                  ${sql.raw(view.view_definition!.trim().replace(/;$/, ''))}\n                  LIMIT\n                    1;\n                `.compile(trx),\n            })\n          )\n        );\n\n        /**\n         * Map of view name to its column meta data results\n         */\n        const columnResultsMap = new Map<\n          string,\n          QueryArrayResult<QueryField[]>\n        >(\n          columnResults.map((result, viewIndex) => [\n            databaseViews[viewIndex]!.table_name,\n            result,\n          ])\n        );\n\n        // Get the schema meta data for the tables/columns found via the above tableIDs\n        const databaseColumns = await trx\n          .selectFrom(`${schema}.schema_columns`)\n          .selectAll()\n          .where(\n            'table_id',\n            'in',\n            Array.from(\n              new Set<number>(\n                columnResults.flatMap(result =>\n                  result.fields.map(field => field.tableID)\n                )\n              )\n            )\n          )\n          .execute();\n\n        /**\n         * Column info map that can be got by [column.table_id, column.column_id].join('_')\n         * !IMPORTANT: These records will only be columns that actually exist in postgres - i.e. calculated columns will not appear (those only appear in the column results from query service)\n         */\n        const pgColumnMap = new Map(\n          databaseColumns.map(column => [\n            [column.table_id, column.column_id].join('_'),\n            column,\n          ])\n        );\n\n        // Delete views that no longer exist\n        await trx\n          .deleteFrom('configuration.view')\n          .where('name', 'not in', Array.from(databaseViewSet))\n          .where('schema', '=', schema)\n          .execute();\n\n        // Update or create views and their columns\n        for (const databaseView of databaseViews) {\n          const databaseViewColumns = columnResultsMap.get(\n            databaseView.table_name\n          );\n\n          if (!databaseViewColumns?.fields.length) {\n            throw new Error(\n              'No columns found for view - this will result in deletion of all columns for view.'\n            );\n          }\n\n          // Upsert the view record\n          const insertedView = await trx\n            .insertInto('configuration.view')\n            .values(() => {\n              const postgrestEntry = schemaCacheMap.get(\n                databaseView.table_name\n              );\n              return {\n                name: databaseView.table_name,\n                pg_primary_table: databaseView.table_name\n                  .replace('_p_', '')\n                  .replace('_c_', ''),\n                schema,\n                updated_at: new Date(),\n                pgt_deletable: postgrestEntry?.tableDeletable ?? false,\n                pgt_description: postgrestEntry?.tableDescription,\n                pgt_insertable: postgrestEntry?.tableInsertable ?? false,\n                pgt_is_view: postgrestEntry?.tableIsView ?? false,\n                pgt_updatable: postgrestEntry?.tableUpdatable ?? false,\n                pgt_pk_cols: postgrestEntry?.tablePKCols,\n                type: SchematicService.viewType(databaseView.table_name),\n              } satisfies Insertable<ConfigurationView>;\n            })\n            .onConflict(oc =>\n              oc.columns(['schema', 'name']).doUpdateSet(eb => ({\n                updated_at: new Date(),\n                pg_primary_table: eb.ref('excluded.pg_primary_table'),\n                pgt_deletable: eb.ref('excluded.pgt_deletable'),\n                pgt_insertable: eb.ref('excluded.pgt_insertable'),\n                pgt_description: eb.ref('excluded.pgt_description'),\n                pgt_is_view: eb.ref('excluded.pgt_is_view'),\n                pgt_updatable: eb.ref('excluded.pgt_updatable'),\n                pgt_pk_cols: eb.ref('excluded.pgt_pk_cols'),\n              }))\n            )\n            .returningAll()\n            .executeTakeFirstOrThrow();\n\n          // Delete removed columns\n          await trx\n            .deleteFrom('configuration.column')\n            .where('view_name', '=', insertedView.name)\n            .where('schema', '=', schema)\n            .where(\n              'name',\n              'not in',\n              databaseViewColumns.fields.map(field => field.name)\n            )\n            .execute();\n\n          // Upsert columns\n          await trx\n            .insertInto('configuration.column')\n            .values(\n              databaseViewColumns.fields.map(field => {\n                // Find the pg column data using the ids if it exists\n                const pgColumn = pgColumnMap.get(\n                  [field.tableID, field.columnID].join('_')\n                );\n\n                // Find the postgrest Column Info\n                let postgrestColumn = schemaCacheMap.get(\n                  databaseView.table_name\n                )?.tableColumns[field.name];\n                if (\n                  SchematicService.hasUnderlyingTable(databaseView.table_name)\n                ) {\n                  const underlyingColumn = schemaCacheMap.get(\n                    databaseView.table_name.replace('_p_', '')\n                  )?.tableColumns[field.name];\n                  postgrestColumn = underlyingColumn ?? postgrestColumn;\n                }\n\n                const data_type =\n                  PostgresSupportedDataTypeIdMap[field.dataTypeID] ??\n                  supported_pg_data_type.enum;\n\n                return {\n                  schema,\n                  view_name: insertedView.name,\n                  name: field.name,\n\n                  oid: field.dataTypeID,\n                  table_id: field.tableID,\n                  column_id: field.columnID,\n                  data_type,\n                  pgt_type: postgrestColumn?.colType ?? 'unknown',\n                  pgt_nominal_type: postgrestColumn?.colNominalType,\n                  cell_type: PGDataCellMap[data_type],\n                  field_type: PGDataFieldMap[data_type],\n                  pgt_max_len: postgrestColumn?.colMaxLen,\n                  pgt_enum: postgrestColumn?.colEnum ?? [],\n                  pgt_description: postgrestColumn?.colDescription,\n                  pgt_name: postgrestColumn?.colName,\n                  pgt_nullable:\n                    postgrestColumn?.colNullable ??\n                    (pgColumn?.is_nullable === 'YES' ? true : false),\n                  updated_at: new Date(),\n                  // Attributes below will should only be populated for columns that exist as true columns in the DB\n                  // We try and fil them using postgrest info first\n                  pg_table: pgColumn?.table_name,\n                  pg_column: pgColumn?.column_name,\n                  is_unique: pgColumn?.has_unique_index ?? undefined,\n                  is_updatable: pgColumn?.is_updatable === 'YES',\n                  is_pk: schemaCacheMap\n                    .get(databaseView.table_name)\n                    ?.tablePKCols.includes(postgrestColumn?.colName ?? ''),\n                  // references_table: pgColumn?.references_table,\n                  pgt_default:\n                    postgrestColumn?.colDefault?.toString() ??\n                    pgColumn?.column_default?.toString(),\n                } satisfies Insertable<ConfigurationColumn>;\n              })\n            )\n            .onConflict(oc =>\n              oc.columns(['schema', 'view_name', 'name']).doUpdateSet(eb => ({\n                updated_at: eb.ref('excluded.updated_at'),\n                oid: eb.ref('excluded.oid'),\n                table_id: eb.ref('excluded.table_id'),\n                column_id: eb.ref('excluded.column_id'),\n                data_type: eb.ref('excluded.data_type'),\n                pgt_type: eb.ref('excluded.pgt_type'),\n                pgt_nominal_type: eb.ref('excluded.pgt_nominal_type'),\n                cell_type: eb.ref('excluded.cell_type'),\n                field_type: eb.ref('excluded.field_type'),\n                pgt_max_len: eb.ref('excluded.pgt_max_len'),\n                pgt_enum: eb.ref('excluded.pgt_enum'),\n                pgt_description: eb.ref('excluded.pgt_description'),\n                pgt_name: eb.ref('excluded.pgt_name'),\n                pgt_nullable: eb.ref('excluded.pgt_nullable'),\n                pg_table: eb.ref('excluded.pg_table'),\n                pg_column: eb.ref('excluded.pg_column'),\n                is_unique: eb.ref('excluded.is_unique'),\n                is_updatable: eb.ref('excluded.is_updatable'),\n                pgt_default: eb.ref('excluded.pgt_default'),\n                is_pk: eb.ref('excluded.is_pk'),\n              }))\n            )\n            .returning(['name', 'view_name'])\n            .execute();\n        }\n\n        await trx\n          .insertInto('configuration.link')\n          .values(schematicLinks)\n          .onConflict(oc => {\n            return oc\n              .columns([\n                'schema',\n                'source_view_name',\n                'source_column_name',\n                'target_view_name',\n                'target_column_name',\n              ])\n              .doUpdateSet(eb => {\n                return {\n                  type: eb.ref('excluded.type'),\n                  pgt_columns: eb.ref('excluded.pgt_columns'),\n                  constraint: eb.ref('excluded.constraint'),\n                  source_column_name: eb.ref('excluded.source_column_name'),\n                  target_view_name: eb.ref('excluded.target_view_name'),\n                  target_column_name: eb.ref('excluded.target_column_name'),\n                  pgt_is_self: eb.ref('excluded.pgt_is_self'),\n                  constraint_2: eb.ref('excluded.constraint_2'),\n                  pgt_columns_2: eb.ref('excluded.pgt_columns_2'),\n                  junction_view_name: eb.ref('excluded.junction_view_name'),\n                  junction_source_column_name: eb.ref(\n                    'excluded.junction_source_column_name'\n                  ),\n                  junction_target_column_name: eb.ref(\n                    'excluded.junction_target_column_name'\n                  ),\n                };\n              });\n          })\n          .execute();\n      }\n    });\n\n    // sync admin view\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await Promise.all(\n      schemas.map(schema =>\n        this.syncRoleViews({\n          roleName: 'admin',\n          schema,\n        })\n      )\n    );\n  }\n\n  /**\n   * Syncs the role views, columns, and links to what is in the database\n   *\n   * !IMPORTANT - These operates need to be an upsert and not delete and recreate as their will be additional assets related to them\n   *\n   * @param views A set of views to only do the schematic for (to filter the schematic for)\n   */\n  async syncRoleViews({\n    roleName,\n    schema = 'foundation',\n    trx,\n    views,\n  }: {\n    roleName: string;\n    schema?: AuthSchema;\n    views?: (keyof TDatabase)[];\n    trx?: Database;\n  }) {\n    const database = trx ?? this.database;\n\n    const { schematicLinks, schematicViews } =\n      await this.schematicService.roleSchematic({\n        roleName,\n        schema,\n        views,\n      });\n\n    // Step 1: Upsert all views and delete ones not in DB\n    const deleteViewsQuery = database\n      .deleteFrom('configuration.role_view')\n      .where('schema', '=', schema)\n      .where(\n        'name',\n        'not in',\n        schematicViews.map(roleView => roleView[0].qiName)\n      );\n    if (views) {\n      // if were only doing this sync for a specifc views we must filter by them\n      deleteViewsQuery.where('name', 'in', views);\n    }\n    await Promise.all([\n      database\n        .insertInto('configuration.role_view')\n        .values(\n          schematicViews.map(roleView => {\n            const name = roleView[0].qiName;\n\n            return {\n              name,\n              schema,\n              role_name: roleName,\n              view_name: name.replace(/__.*/, ''),\n            } satisfies Insertable<ConfigurationRoleView>;\n          })\n        )\n        .onConflict(oc => oc.doNothing())\n        .execute(),\n      deleteViewsQuery.execute(),\n    ]);\n\n    // Step 2: Upsert role columns\n    await database\n      .insertInto('configuration.role_column')\n      .values(\n        schematicViews.flatMap(roleView => {\n          const role_view_name = roleView[0].qiName;\n          return Object.keys(roleView[1].tableColumns).map(name => {\n            return {\n              name,\n              schema,\n              role_view_name,\n              view_name: SchematicService.rootViewFromRoleView({\n                rootView: role_view_name as keyof TDatabase,\n              }),\n            } satisfies Insertable<ConfigurationRoleColumn>;\n          });\n        })\n      )\n      .onConflict(oc => oc.doNothing())\n      .returningAll()\n      .execute();\n\n    // Step 3: delete role columns from prexisting view - break this up by view so \"not in\" statements dont overflow\n    await Promise.all(\n      schematicViews.map(roleView => {\n        const role_view_name = roleView[0].qiName;\n        return database\n          .deleteFrom('configuration.role_column')\n          .where('schema', '=', schema)\n          .where('role_view_name', '=', role_view_name)\n          .where('name', 'not in', Object.keys(roleView[1].tableColumns))\n          .execute();\n      })\n    );\n\n    // Step 4: Upsert Links\n    if (schematicLinks.length > 0) {\n      await database\n        .insertInto('configuration.role_link')\n        .values(schematicLinks)\n        .onConflict(oc => oc.doNothing())\n        .returningAll()\n        .execute();\n    }\n\n    // Step 5: Delete links\n    // For now I am going to aassume that cascades will delete these properly - if a role view or any column used in a link is removed the link should also get deleted\n  }\n\n  async mutateRoleViews({\n    columnEnabledRecords,\n    schema = 'foundation',\n    rootViewName,\n  }: {\n    columnEnabledRecords: ColumnEnabledRecord[];\n    rootViewName: keyof TDatabase;\n    schema?: AuthSchema;\n  }) {\n    // Get the current roles in the system\n    const roles = (await this.database\n      .selectFrom('configuration.role')\n      .where('name', '!=', 'admin')\n      .where('schema', '=', schema)\n      .selectAll()\n      .execute()) as Role[];\n\n    const roleColumns = new Map<string, Record<string, boolean>>(\n      roles.map(role => [role.name, {}])\n    );\n\n    // Loop over the records per column and build the result per role into roleColumns\n    for (const role of roles) {\n      const atLeastOneColumnEnabledForRole = columnEnabledRecords.some(record =>\n        Boolean(record[role.name])\n      );\n\n      // If we are enabling at least one column we set the PK record to enabled as well for the role\n      if (atLeastOneColumnEnabledForRole) {\n        const pkRecord = columnEnabledRecords.find(\n          record => record.is_pk === true\n        );\n        if (pkRecord) {\n          pkRecord[role.name] = true;\n        }\n      }\n\n      for (const record of columnEnabledRecords) {\n        roleColumns.set(role.name, {\n          ...roleColumns.get(role.name),\n          // See if the column is enabled for the role\n          [record.name]: Boolean(\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            record[role.name] ||\n              // Auto add primary key if any column is enabled\n              (record.is_pk && atLeastOneColumnEnabledForRole)\n          ),\n        });\n      }\n    }\n\n    // For now we are going to drop and recreate - create and replace has potential conflicts via column renaming\n    // Possible in the future to do create and replace\n    const databaseRoleViews: [keyof TDatabase, Role][] = [];\n    await this.database.transaction().execute(async trx => {\n      // Step 1: Rebuild role views in database\n      await Promise.all(\n        roles.map(async role => {\n          const roleViewName = SchematicService.roleViewName({\n            rootViewName,\n            role,\n          });\n          // first drop the view for each role\n          const columns: string[] = Object.entries(\n            roleColumns.get(role.name) ?? []\n          )\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            .filter(([_key, value]) => value)\n            .map(([key]) => key);\n\n          await trx.schema\n            .dropView(`${schema}.${roleViewName}`)\n            .ifExists()\n            .execute();\n\n          // Then create it if there are columns\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (columns.length > 0) {\n            await trx.schema\n              .createView(`${schema}.${roleViewName}`)\n              .orReplace()\n              .as(\n                this.database\n                  // @ts-expect-error columns whould work\n                  .selectFrom(`${schema}.${rootViewName}`)\n                  // @ts-expect-error columns whould work\n                  .select(columns)\n              )\n              .execute();\n            databaseRoleViews.push([roleViewName, role]);\n          } else {\n            await trx // view is already gone in the DB - we also need to remove its role_view record\n              .deleteFrom('configuration.role_view')\n              .where(\n                'name',\n                '=',\n                SchematicService.roleViewName({ rootViewName, role })\n              )\n              .where('schema', '=', schema)\n              .execute();\n          }\n        })\n      );\n    });\n    // Close the transaction so the postgrest server updates\n    // TODO: maybe move this to be triggered by postgrest update itself\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    // Step 2: Resync each of the views per role\n    if (databaseRoleViews.length > 0) {\n      await Promise.all(\n        databaseRoleViews.map(roleView =>\n          this.syncRoleViews({\n            roleName: roleView[1].name,\n            views: [roleView[0]],\n          })\n        )\n      );\n    }\n    return 'ok';\n  }\n\n  async viewDefinition({\n    viewName,\n    schema = 'foundation',\n  }: {\n    viewName: string;\n    id: string;\n    schema?: AuthSchema;\n  }): Promise<z.infer<typeof ViewDefinition>> {\n    const view = await this.database\n      .selectFrom('information_schema.views')\n      .select(['table_name', 'table_schema', 'view_definition'])\n      .where('table_name', '=', viewName)\n      .where('table_schema', '=', schema)\n      .executeTakeFirstOrThrow();\n\n    return view;\n  }\n}\n"],"names":["Inject","Injectable","Logger","sql","supported_pg_data_type","PGDataCellMap","PGDataFieldMap","PostgresSupportedDataTypeIdMap","Database","QueryService","SchematicService","ViewService","constructor","database","queryService","schematicService","logger","name","syncViews","schemas","join","execute","transaction","trx","schema","schemaCacheMap","schematicViews","schematicLinks","rootSchematic","databaseViews","selectFrom","select","where","map","view","qiName","databaseViewSet","Set","v","table_name","columnResults","Promise","all","query","raw","view_definition","trim","replace","compile","columnResultsMap","Map","result","viewIndex","databaseColumns","selectAll","Array","from","flatMap","fields","field","tableID","pgColumnMap","column","table_id","column_id","deleteFrom","databaseView","databaseViewColumns","get","length","Error","insertedView","insertInto","values","postgrestEntry","pg_primary_table","updated_at","Date","pgt_deletable","tableDeletable","pgt_description","tableDescription","pgt_insertable","tableInsertable","pgt_is_view","tableIsView","pgt_updatable","tableUpdatable","pgt_pk_cols","tablePKCols","type","viewType","onConflict","oc","columns","doUpdateSet","eb","ref","returningAll","executeTakeFirstOrThrow","pgColumn","columnID","postgrestColumn","tableColumns","hasUnderlyingTable","underlyingColumn","data_type","dataTypeID","enum","view_name","oid","pgt_type","colType","pgt_nominal_type","colNominalType","cell_type","field_type","pgt_max_len","colMaxLen","pgt_enum","colEnum","colDescription","pgt_name","colName","pgt_nullable","colNullable","is_nullable","pg_table","pg_column","column_name","is_unique","has_unique_index","undefined","is_updatable","is_pk","includes","pgt_default","colDefault","toString","column_default","returning","pgt_columns","constraint","source_column_name","target_view_name","target_column_name","pgt_is_self","constraint_2","pgt_columns_2","junction_view_name","junction_source_column_name","junction_target_column_name","resolve","setTimeout","syncRoleViews","roleName","views","roleSchematic","deleteViewsQuery","roleView","role_name","doNothing","role_view_name","Object","keys","rootViewFromRoleView","rootView","mutateRoleViews","columnEnabledRecords","rootViewName","roles","roleColumns","role","atLeastOneColumnEnabledForRole","some","record","Boolean","pkRecord","find","set","databaseRoleViews","roleViewName","entries","filter","_key","value","key","dropView","ifExists","createView","orReplace","as","push","viewDefinition","viewName"],"mappings":";;;;;;;;;;;;;;AAAA,SAASA,MAAM,EAAEC,UAAU,EAAEC,MAAM,QAAQ,iBAAiB;AAC5D,SAASC,GAAG,QAAyB,SAAS;AAS9C,SAASC,sBAAsB,QAAQ,iBAAiB;AAGxD,SACEC,aAAa,EACbC,cAAc,EACdC,8BAA8B,QAEzB,kBAAe;AAEtB,SAASC,QAAQ,QAAwB,0BAAsB;AAC/D,SAASC,YAAY,QAAyB,4BAAwB;AACtE,SAASC,gBAAgB,QAAQ,oCAAgC;AAiBjE,OAAO,MAAMC;IAGXC,YACE,AAAmCC,QAAkB,EACrD,AAAiBC,YAA0B,EAC3C,AAAiBC,gBAAkC,CACnD;aAHmCF,WAAAA;aAClBC,eAAAA;aACAC,mBAAAA;aALFC,SAAS,IAAId,OAAOS,YAAYM,IAAI;IAMlD;IAEH,wCAAwC;IACxC,MAAMC,UAAU,EACdC,OAAO,EAOR,EAAE;QACD,MAAMhB,GAAG,CAAC,+CAA+C,EAAEA,IAAIiB,IAAI,CAACD,SAAS,WAAW,CAAC,CAACE,OAAO,CAC/F,IAAI,CAACR,QAAQ;QAEf,wDAAwD;QACxD,MAAM,IAAI,CAACA,QAAQ,CAACS,WAAW,GAAGD,OAAO,CAAC,OAAME;YAC9C,KAAK,MAAMC,UAAUL,QAAS;gBAC5B,MAAM,EAAEM,cAAc,EAAEC,cAAc,EAAEC,cAAc,EAAE,GACtD,MAAM,IAAI,CAACZ,gBAAgB,CAACa,aAAa,CAAC;oBAAEJ;gBAAO;gBACrD,wCAAwC;gBACxC,oDAAoD;gBACpD,MAAMK,gBAAgB,MAAM,IAAI,CAAChB,QAAQ,CACtCiB,UAAU,CAAC,4BACXC,MAAM,CAAC;oBAAC;oBAAc;oBAAgB;iBAAkB,EACxDC,KAAK,CACJ,cACA,MACAN,eAAeO,GAAG,CAACC,CAAAA,OAAQA,IAAI,CAAC,EAAE,CAACC,MAAM,GAE1Cd,OAAO;gBAEV,oCAAoC;gBACpC,MAAMe,kBAAkB,IAAIC,IAAIR,cAAcI,GAAG,CAACK,CAAAA,IAAKA,EAAEC,UAAU;gBAEnE,iEAAiE;gBACjE,MAAMC,gBAAgB,MAAMC,QAAQC,GAAG,CACrCb,cAAcI,GAAG,CAACC,CAAAA,OAChB,IAAI,CAACpB,YAAY,CAACO,OAAO,CAAe;wBACtCsB,OAAOxC,GAAG,CAAC;kBACP,EAAEA,IAAIyC,GAAG,CAACV,KAAKW,eAAe,CAAEC,IAAI,GAAGC,OAAO,CAAC,MAAM,KAAK;;;gBAG5D,CAAC,CAACC,OAAO,CAACzB;oBACd;gBAIJ;;SAEC,GACD,MAAM0B,mBAAmB,IAAIC,IAI3BV,cAAcP,GAAG,CAAC,CAACkB,QAAQC,YAAc;wBACvCvB,aAAa,CAACuB,UAAU,CAAEb,UAAU;wBACpCY;qBACD;gBAGH,+EAA+E;gBAC/E,MAAME,kBAAkB,MAAM9B,IAC3BO,UAAU,CAAC,GAAGN,OAAO,eAAe,CAAC,EACrC8B,SAAS,GACTtB,KAAK,CACJ,YACA,MACAuB,MAAMC,IAAI,CACR,IAAInB,IACFG,cAAciB,OAAO,CAACN,CAAAA,SACpBA,OAAOO,MAAM,CAACzB,GAAG,CAAC0B,CAAAA,QAASA,MAAMC,OAAO,MAK/CvC,OAAO;gBAEV;;;SAGC,GACD,MAAMwC,cAAc,IAAIX,IACtBG,gBAAgBpB,GAAG,CAAC6B,CAAAA,SAAU;wBAC5B;4BAACA,OAAOC,QAAQ;4BAAED,OAAOE,SAAS;yBAAC,CAAC5C,IAAI,CAAC;wBACzC0C;qBACD;gBAGH,oCAAoC;gBACpC,MAAMvC,IACH0C,UAAU,CAAC,sBACXjC,KAAK,CAAC,QAAQ,UAAUuB,MAAMC,IAAI,CAACpB,kBACnCJ,KAAK,CAAC,UAAU,KAAKR,QACrBH,OAAO;gBAEV,2CAA2C;gBAC3C,KAAK,MAAM6C,gBAAgBrC,cAAe;oBACxC,MAAMsC,sBAAsBlB,iBAAiBmB,GAAG,CAC9CF,aAAa3B,UAAU;oBAGzB,IAAI,CAAC4B,qBAAqBT,OAAOW,QAAQ;wBACvC,MAAM,IAAIC,MACR;oBAEJ;oBAEA,yBAAyB;oBACzB,MAAMC,eAAe,MAAMhD,IACxBiD,UAAU,CAAC,sBACXC,MAAM,CAAC;wBACN,MAAMC,iBAAiBjD,eAAe2C,GAAG,CACvCF,aAAa3B,UAAU;wBAEzB,OAAO;4BACLtB,MAAMiD,aAAa3B,UAAU;4BAC7BoC,kBAAkBT,aAAa3B,UAAU,CACtCQ,OAAO,CAAC,OAAO,IACfA,OAAO,CAAC,OAAO;4BAClBvB;4BACAoD,YAAY,IAAIC;4BAChBC,eAAeJ,gBAAgBK,kBAAkB;4BACjDC,iBAAiBN,gBAAgBO;4BACjCC,gBAAgBR,gBAAgBS,mBAAmB;4BACnDC,aAAaV,gBAAgBW,eAAe;4BAC5CC,eAAeZ,gBAAgBa,kBAAkB;4BACjDC,aAAad,gBAAgBe;4BAC7BC,MAAMhF,iBAAiBiF,QAAQ,CAACzB,aAAa3B,UAAU;wBACzD;oBACF,GACCqD,UAAU,CAACC,CAAAA,KACVA,GAAGC,OAAO,CAAC;4BAAC;4BAAU;yBAAO,EAAEC,WAAW,CAACC,CAAAA,KAAO,CAAA;gCAChDpB,YAAY,IAAIC;gCAChBF,kBAAkBqB,GAAGC,GAAG,CAAC;gCACzBnB,eAAekB,GAAGC,GAAG,CAAC;gCACtBf,gBAAgBc,GAAGC,GAAG,CAAC;gCACvBjB,iBAAiBgB,GAAGC,GAAG,CAAC;gCACxBb,aAAaY,GAAGC,GAAG,CAAC;gCACpBX,eAAeU,GAAGC,GAAG,CAAC;gCACtBT,aAAaQ,GAAGC,GAAG,CAAC;4BACtB,CAAA,IAEDC,YAAY,GACZC,uBAAuB;oBAE1B,yBAAyB;oBACzB,MAAM5E,IACH0C,UAAU,CAAC,wBACXjC,KAAK,CAAC,aAAa,KAAKuC,aAAatD,IAAI,EACzCe,KAAK,CAAC,UAAU,KAAKR,QACrBQ,KAAK,CACJ,QACA,UACAmC,oBAAoBT,MAAM,CAACzB,GAAG,CAAC0B,CAAAA,QAASA,MAAM1C,IAAI,GAEnDI,OAAO;oBAEV,iBAAiB;oBACjB,MAAME,IACHiD,UAAU,CAAC,wBACXC,MAAM,CACLN,oBAAoBT,MAAM,CAACzB,GAAG,CAAC0B,CAAAA;wBAC7B,qDAAqD;wBACrD,MAAMyC,WAAWvC,YAAYO,GAAG,CAC9B;4BAACT,MAAMC,OAAO;4BAAED,MAAM0C,QAAQ;yBAAC,CAACjF,IAAI,CAAC;wBAGvC,iCAAiC;wBACjC,IAAIkF,kBAAkB7E,eAAe2C,GAAG,CACtCF,aAAa3B,UAAU,GACtBgE,YAAY,CAAC5C,MAAM1C,IAAI,CAAC;wBAC3B,IACEP,iBAAiB8F,kBAAkB,CAACtC,aAAa3B,UAAU,GAC3D;4BACA,MAAMkE,mBAAmBhF,eAAe2C,GAAG,CACzCF,aAAa3B,UAAU,CAACQ,OAAO,CAAC,OAAO,MACtCwD,YAAY,CAAC5C,MAAM1C,IAAI,CAAC;4BAC3BqF,kBAAkBG,oBAAoBH;wBACxC;wBAEA,MAAMI,YACJnG,8BAA8B,CAACoD,MAAMgD,UAAU,CAAC,IAChDvG,uBAAuBwG,IAAI;wBAE7B,OAAO;4BACLpF;4BACAqF,WAAWtC,aAAatD,IAAI;4BAC5BA,MAAM0C,MAAM1C,IAAI;4BAEhB6F,KAAKnD,MAAMgD,UAAU;4BACrB5C,UAAUJ,MAAMC,OAAO;4BACvBI,WAAWL,MAAM0C,QAAQ;4BACzBK;4BACAK,UAAUT,iBAAiBU,WAAW;4BACtCC,kBAAkBX,iBAAiBY;4BACnCC,WAAW9G,aAAa,CAACqG,UAAU;4BACnCU,YAAY9G,cAAc,CAACoG,UAAU;4BACrCW,aAAaf,iBAAiBgB;4BAC9BC,UAAUjB,iBAAiBkB,WAAW,EAAE;4BACxCxC,iBAAiBsB,iBAAiBmB;4BAClCC,UAAUpB,iBAAiBqB;4BAC3BC,cACEtB,iBAAiBuB,eAChBzB,CAAAA,UAAU0B,gBAAgB,QAAQ,OAAO,KAAI;4BAChDlD,YAAY,IAAIC;4BAChB,kGAAkG;4BAClG,iDAAiD;4BACjDkD,UAAU3B,UAAU7D;4BACpByF,WAAW5B,UAAU6B;4BACrBC,WAAW9B,UAAU+B,oBAAoBC;4BACzCC,cAAcjC,UAAUiC,iBAAiB;4BACzCC,OAAO7G,eACJ2C,GAAG,CAACF,aAAa3B,UAAU,GAC1BkD,YAAY8C,SAASjC,iBAAiBqB,WAAW;4BACrD,gDAAgD;4BAChDa,aACElC,iBAAiBmC,YAAYC,cAC7BtC,UAAUuC,gBAAgBD;wBAC9B;oBACF,IAED9C,UAAU,CAACC,CAAAA,KACVA,GAAGC,OAAO,CAAC;4BAAC;4BAAU;4BAAa;yBAAO,EAAEC,WAAW,CAACC,CAAAA,KAAO,CAAA;gCAC7DpB,YAAYoB,GAAGC,GAAG,CAAC;gCACnBa,KAAKd,GAAGC,GAAG,CAAC;gCACZlC,UAAUiC,GAAGC,GAAG,CAAC;gCACjBjC,WAAWgC,GAAGC,GAAG,CAAC;gCAClBS,WAAWV,GAAGC,GAAG,CAAC;gCAClBc,UAAUf,GAAGC,GAAG,CAAC;gCACjBgB,kBAAkBjB,GAAGC,GAAG,CAAC;gCACzBkB,WAAWnB,GAAGC,GAAG,CAAC;gCAClBmB,YAAYpB,GAAGC,GAAG,CAAC;gCACnBoB,aAAarB,GAAGC,GAAG,CAAC;gCACpBsB,UAAUvB,GAAGC,GAAG,CAAC;gCACjBjB,iBAAiBgB,GAAGC,GAAG,CAAC;gCACxByB,UAAU1B,GAAGC,GAAG,CAAC;gCACjB2B,cAAc5B,GAAGC,GAAG,CAAC;gCACrB8B,UAAU/B,GAAGC,GAAG,CAAC;gCACjB+B,WAAWhC,GAAGC,GAAG,CAAC;gCAClBiC,WAAWlC,GAAGC,GAAG,CAAC;gCAClBoC,cAAcrC,GAAGC,GAAG,CAAC;gCACrBuC,aAAaxC,GAAGC,GAAG,CAAC;gCACpBqC,OAAOtC,GAAGC,GAAG,CAAC;4BAChB,CAAA,IAED2C,SAAS,CAAC;wBAAC;wBAAQ;qBAAY,EAC/BvH,OAAO;gBACZ;gBAEA,MAAME,IACHiD,UAAU,CAAC,sBACXC,MAAM,CAAC9C,gBACPiE,UAAU,CAACC,CAAAA;oBACV,OAAOA,GACJC,OAAO,CAAC;wBACP;wBACA;wBACA;wBACA;wBACA;qBACD,EACAC,WAAW,CAACC,CAAAA;wBACX,OAAO;4BACLN,MAAMM,GAAGC,GAAG,CAAC;4BACb4C,aAAa7C,GAAGC,GAAG,CAAC;4BACpB6C,YAAY9C,GAAGC,GAAG,CAAC;4BACnB8C,oBAAoB/C,GAAGC,GAAG,CAAC;4BAC3B+C,kBAAkBhD,GAAGC,GAAG,CAAC;4BACzBgD,oBAAoBjD,GAAGC,GAAG,CAAC;4BAC3BiD,aAAalD,GAAGC,GAAG,CAAC;4BACpBkD,cAAcnD,GAAGC,GAAG,CAAC;4BACrBmD,eAAepD,GAAGC,GAAG,CAAC;4BACtBoD,oBAAoBrD,GAAGC,GAAG,CAAC;4BAC3BqD,6BAA6BtD,GAAGC,GAAG,CACjC;4BAEFsD,6BAA6BvD,GAAGC,GAAG,CACjC;wBAEJ;oBACF;gBACJ,GACC5E,OAAO;YACZ;QACF;QAEA,kBAAkB;QAClB,MAAM,IAAIoB,QAAQ+G,CAAAA,UAAWC,WAAWD,SAAS;QACjD,MAAM/G,QAAQC,GAAG,CACfvB,QAAQc,GAAG,CAACT,CAAAA,SACV,IAAI,CAACkI,aAAa,CAAC;gBACjBC,UAAU;gBACVnI;YACF;IAGN;IAEA;;;;;;GAMC,GACD,MAAMkI,cAAc,EAClBC,QAAQ,EACRnI,SAAS,YAAY,EACrBD,GAAG,EACHqI,KAAK,EAMN,EAAE;QACD,MAAM/I,WAAWU,OAAO,IAAI,CAACV,QAAQ;QAErC,MAAM,EAAEc,cAAc,EAAED,cAAc,EAAE,GACtC,MAAM,IAAI,CAACX,gBAAgB,CAAC8I,aAAa,CAAC;YACxCF;YACAnI;YACAoI;QACF;QAEF,qDAAqD;QACrD,MAAME,mBAAmBjJ,SACtBoD,UAAU,CAAC,2BACXjC,KAAK,CAAC,UAAU,KAAKR,QACrBQ,KAAK,CACJ,QACA,UACAN,eAAeO,GAAG,CAAC8H,CAAAA,WAAYA,QAAQ,CAAC,EAAE,CAAC5H,MAAM;QAErD,IAAIyH,OAAO;YACT,0EAA0E;YAC1EE,iBAAiB9H,KAAK,CAAC,QAAQ,MAAM4H;QACvC;QACA,MAAMnH,QAAQC,GAAG,CAAC;YAChB7B,SACG2D,UAAU,CAAC,2BACXC,MAAM,CACL/C,eAAeO,GAAG,CAAC8H,CAAAA;gBACjB,MAAM9I,OAAO8I,QAAQ,CAAC,EAAE,CAAC5H,MAAM;gBAE/B,OAAO;oBACLlB;oBACAO;oBACAwI,WAAWL;oBACX9C,WAAW5F,KAAK8B,OAAO,CAAC,QAAQ;gBAClC;YACF,IAED6C,UAAU,CAACC,CAAAA,KAAMA,GAAGoE,SAAS,IAC7B5I,OAAO;YACVyI,iBAAiBzI,OAAO;SACzB;QAED,8BAA8B;QAC9B,MAAMR,SACH2D,UAAU,CAAC,6BACXC,MAAM,CACL/C,eAAe+B,OAAO,CAACsG,CAAAA;YACrB,MAAMG,iBAAiBH,QAAQ,CAAC,EAAE,CAAC5H,MAAM;YACzC,OAAOgI,OAAOC,IAAI,CAACL,QAAQ,CAAC,EAAE,CAACxD,YAAY,EAAEtE,GAAG,CAAChB,CAAAA;gBAC/C,OAAO;oBACLA;oBACAO;oBACA0I;oBACArD,WAAWnG,iBAAiB2J,oBAAoB,CAAC;wBAC/CC,UAAUJ;oBACZ;gBACF;YACF;QACF,IAEDtE,UAAU,CAACC,CAAAA,KAAMA,GAAGoE,SAAS,IAC7B/D,YAAY,GACZ7E,OAAO;QAEV,gHAAgH;QAChH,MAAMoB,QAAQC,GAAG,CACfhB,eAAeO,GAAG,CAAC8H,CAAAA;YACjB,MAAMG,iBAAiBH,QAAQ,CAAC,EAAE,CAAC5H,MAAM;YACzC,OAAOtB,SACJoD,UAAU,CAAC,6BACXjC,KAAK,CAAC,UAAU,KAAKR,QACrBQ,KAAK,CAAC,kBAAkB,KAAKkI,gBAC7BlI,KAAK,CAAC,QAAQ,UAAUmI,OAAOC,IAAI,CAACL,QAAQ,CAAC,EAAE,CAACxD,YAAY,GAC5DlF,OAAO;QACZ;QAGF,uBAAuB;QACvB,IAAIM,eAAe0C,MAAM,GAAG,GAAG;YAC7B,MAAMxD,SACH2D,UAAU,CAAC,2BACXC,MAAM,CAAC9C,gBACPiE,UAAU,CAACC,CAAAA,KAAMA,GAAGoE,SAAS,IAC7B/D,YAAY,GACZ7E,OAAO;QACZ;IAEA,uBAAuB;IACvB,mKAAmK;IACrK;IAEA,MAAMkJ,gBAAgB,EACpBC,oBAAoB,EACpBhJ,SAAS,YAAY,EACrBiJ,YAAY,EAKb,EAAE;QACD,sCAAsC;QACtC,MAAMC,QAAS,MAAM,IAAI,CAAC7J,QAAQ,CAC/BiB,UAAU,CAAC,sBACXE,KAAK,CAAC,QAAQ,MAAM,SACpBA,KAAK,CAAC,UAAU,KAAKR,QACrB8B,SAAS,GACTjC,OAAO;QAEV,MAAMsJ,cAAc,IAAIzH,IACtBwH,MAAMzI,GAAG,CAAC2I,CAAAA,OAAQ;gBAACA,KAAK3J,IAAI;gBAAE,CAAC;aAAE;QAGnC,kFAAkF;QAClF,KAAK,MAAM2J,QAAQF,MAAO;YACxB,MAAMG,iCAAiCL,qBAAqBM,IAAI,CAACC,CAAAA,SAC/DC,QAAQD,MAAM,CAACH,KAAK3J,IAAI,CAAC;YAG3B,8FAA8F;YAC9F,IAAI4J,gCAAgC;gBAClC,MAAMI,WAAWT,qBAAqBU,IAAI,CACxCH,CAAAA,SAAUA,OAAOzC,KAAK,KAAK;gBAE7B,IAAI2C,UAAU;oBACZA,QAAQ,CAACL,KAAK3J,IAAI,CAAC,GAAG;gBACxB;YACF;YAEA,KAAK,MAAM8J,UAAUP,qBAAsB;gBACzCG,YAAYQ,GAAG,CAACP,KAAK3J,IAAI,EAAE;oBACzB,GAAG0J,YAAYvG,GAAG,CAACwG,KAAK3J,IAAI,CAAC;oBAC7B,4CAA4C;oBAC5C,CAAC8J,OAAO9J,IAAI,CAAC,EAAE+J,QACb,wEAAwE;oBACxED,MAAM,CAACH,KAAK3J,IAAI,CAAC,IACf,gDAAgD;oBAC/C8J,OAAOzC,KAAK,IAAIuC;gBAEvB;YACF;QACF;QAEA,6GAA6G;QAC7G,kDAAkD;QAClD,MAAMO,oBAA+C,EAAE;QACvD,MAAM,IAAI,CAACvK,QAAQ,CAACS,WAAW,GAAGD,OAAO,CAAC,OAAME;YAC9C,yCAAyC;YACzC,MAAMkB,QAAQC,GAAG,CACfgI,MAAMzI,GAAG,CAAC,OAAM2I;gBACd,MAAMS,eAAe3K,iBAAiB2K,YAAY,CAAC;oBACjDZ;oBACAG;gBACF;gBACA,oCAAoC;gBACpC,MAAM9E,UAAoBqE,OAAOmB,OAAO,CACtCX,YAAYvG,GAAG,CAACwG,KAAK3J,IAAI,KAAK,EAAE,CAEhC,6DAA6D;iBAC5DsK,MAAM,CAAC,CAAC,CAACC,MAAMC,MAAM,GAAKA,OAC1BxJ,GAAG,CAAC,CAAC,CAACyJ,IAAI,GAAKA;gBAElB,MAAMnK,IAAIC,MAAM,CACbmK,QAAQ,CAAC,GAAGnK,OAAO,CAAC,EAAE6J,cAAc,EACpCO,QAAQ,GACRvK,OAAO;gBAEV,sCAAsC;gBACtC,kDAAkD;gBAClD,IAAIyE,QAAQzB,MAAM,GAAG,GAAG;oBACtB,MAAM9C,IAAIC,MAAM,CACbqK,UAAU,CAAC,GAAGrK,OAAO,CAAC,EAAE6J,cAAc,EACtCS,SAAS,GACTC,EAAE,CACD,IAAI,CAAClL,QAAQ,AACX,uCAAuC;qBACtCiB,UAAU,CAAC,GAAGN,OAAO,CAAC,EAAEiJ,cAAc,CACvC,uCAAuC;qBACtC1I,MAAM,CAAC+D,UAEXzE,OAAO;oBACV+J,kBAAkBY,IAAI,CAAC;wBAACX;wBAAcT;qBAAK;gBAC7C,OAAO;oBACL,MAAMrJ,IAAI,+EAA+E;qBACtF0C,UAAU,CAAC,2BACXjC,KAAK,CACJ,QACA,KACAtB,iBAAiB2K,YAAY,CAAC;wBAAEZ;wBAAcG;oBAAK,IAEpD5I,KAAK,CAAC,UAAU,KAAKR,QACrBH,OAAO;gBACZ;YACF;QAEJ;QACA,wDAAwD;QACxD,mEAAmE;QACnE,MAAM,IAAIoB,QAAQ+G,CAAAA,UAAWC,WAAWD,SAAS;QACjD,4CAA4C;QAC5C,IAAI4B,kBAAkB/G,MAAM,GAAG,GAAG;YAChC,MAAM5B,QAAQC,GAAG,CACf0I,kBAAkBnJ,GAAG,CAAC8H,CAAAA,WACpB,IAAI,CAACL,aAAa,CAAC;oBACjBC,UAAUI,QAAQ,CAAC,EAAE,CAAC9I,IAAI;oBAC1B2I,OAAO;wBAACG,QAAQ,CAAC,EAAE;qBAAC;gBACtB;QAGN;QACA,OAAO;IACT;IAEA,MAAMkC,eAAe,EACnBC,QAAQ,EACR1K,SAAS,YAAY,EAKtB,EAA2C;QAC1C,MAAMU,OAAO,MAAM,IAAI,CAACrB,QAAQ,CAC7BiB,UAAU,CAAC,4BACXC,MAAM,CAAC;YAAC;YAAc;YAAgB;SAAkB,EACxDC,KAAK,CAAC,cAAc,KAAKkK,UACzBlK,KAAK,CAAC,gBAAgB,KAAKR,QAC3B2E,uBAAuB;QAE1B,OAAOjE;IACT;AACF"}